# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def abbrev(pattern=T.unsafe(nil)); end

  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.ver(); end
end

class Binding
  def clone(); end

  def irb(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def lockfile_upgrade_warning?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class Date
  WEEKDAYS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

class DidYouMean::DeprecatedIgnoredCallers
  def +(*_); end

  def <<(*_); end
end

class DidYouMean::DeprecatedIgnoredCallers
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::SpellChecker
  def correct(input); end

  def initialize(dictionary:); end
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_PREDEFINED_OBJECTS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

module Diff::LCS
  VERSION = ::T.let(nil, ::T.untyped)
end

Diff::LCS::BalancedCallbacks = Diff::LCS::DefaultCallbacks

class Diff::LCS::Change
  VALID_ACTIONS = ::T.let(nil, ::T.untyped)
end

Diff::LCS::SequenceCallbacks = Diff::LCS::DefaultCallbacks

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def zip(*_); end
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir(); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid(); end

  def gid=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end

  def shell(); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid(); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

module Etc
  def self.confstr(_); end

  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(*_); end

  def self.getgrnam(_); end

  def self.getlogin(); end

  def self.getpwent(); end

  def self.getpwnam(_); end

  def self.getpwuid(*_); end

  def self.group(); end

  def self.nprocessors(); end

  def self.passwd(); end

  def self.setgrent(); end

  def self.setpwent(); end

  def self.sysconf(_); end

  def self.sysconfdir(); end

  def self.systmpdir(); end

  def self.uname(); end
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

class FrozenError
end

class FrozenError
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

module Gem::BundlerVersionFinder
  def self.without_filtering(); end
end

class Gem::DependencyInstaller
  def _deprecated_gems_to_install(); end

  def gems_to_install(*args, &block); end
end

class Gem::Resolver
end

Gem::DependencyResolver::Conflict = Gem::Resolver::Conflict

Gem::DependencyResolver::DependencyConflict = Gem::Resolver::Conflict

module Gem::Resolver::Molinillo
end

Gem::DependencyResolver::Molinillo::SpecificationProvider = Gem::Resolver::Molinillo::SpecificationProvider

Gem::DependencyResolver::Molinillo::UI = Gem::Resolver::Molinillo::UI

module Gem::Resolver::Molinillo
end

class Gem::Resolver
end

class Gem::Installer
  def verify_spec_name(); end
end

class Gem::Licenses
  IDENTIFIERS = ::T.let(nil, ::T.untyped)
end

class Gem::Package
  def realpath(file); end
end

class Gem::RemoteFetcher
  def api_endpoint(uri); end
end

Gem::RequestSet::GemDepedencyAPI = Gem::RequestSet::GemDependencyAPI

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Source
  def api_uri(); end
end

class Gem::Specification
  def bundled_gem_in_old_ruby?(); end

  def rubyforge_project(); end

  def warning(statement); end
end

class Gem::Specification
  extend ::Enumerable
end

module Gem::Util
  NULL_DEVICE = ::T.let(nil, ::T.untyped)
end

module Gem
  def self._deprecated_datadir(gem_name); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def dig(*_); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def merge!(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.foreach(*_); end

  def self.open(*_); end

  def self.pipe(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

module Marshal
  def self.restore(*_); end
end

Methods = T::Private::Methods

class Module
  def deprecate_constant(*_); end

  def undef_method(*_); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

module OpenURI
  Options = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end

  def io(); end
end

class OpenURI::HTTPError
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end

  def uri(); end
end

class OpenURI::HTTPRedirect
end

module OpenURI::Meta
  def base_uri(); end

  def base_uri=(base_uri); end

  def charset(); end

  def content_encoding(); end

  def content_type(); end

  def content_type_parse(); end

  def last_modified(); end

  def meta(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end

  def metas(); end

  def status(); end

  def status=(status); end
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
end

module OpenURI::Meta
  def self.init(obj, src=T.unsafe(nil)); end
end

module OpenURI::OpenRead
  def open(*rest, &block); end

  def read(options=T.unsafe(nil)); end
end

module OpenURI::OpenRead
end

module OpenURI
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def ===(*_); end

  def clone(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

module RDoc
  ATTR_MODIFIERS = ::T.let(nil, ::T.untyped)
  CLASS_MODIFIERS = ::T.let(nil, ::T.untyped)
  CONSTANT_MODIFIERS = ::T.let(nil, ::T.untyped)
  DOT_DOC_FILENAME = ::T.let(nil, ::T.untyped)
  GENERAL_MODIFIERS = ::T.let(nil, ::T.untyped)
  KNOWN_CLASSES = ::T.let(nil, ::T.untyped)
  METHOD_MODIFIERS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VISIBILITIES = ::T.let(nil, ::T.untyped)
end

class RDoc::Alias
  def aref(); end

  def full_old_name(); end

  def html_name(); end

  def initialize(text, old_name, new_name, comment, singleton=T.unsafe(nil)); end

  def name(); end

  def name_prefix(); end

  def new_name(); end

  def old_name(); end

  def pretty_name(); end

  def pretty_new_name(); end

  def pretty_old_name(); end

  def singleton(); end

  def singleton=(singleton); end

  def text(); end
end

class RDoc::Alias
end

class RDoc::AnonClass
end

class RDoc::AnonClass
end

class RDoc::AnyMethod
  include ::RDoc::TokenStream
  def add_alias(an_alias, context=T.unsafe(nil)); end

  def c_function(); end

  def c_function=(c_function); end

  def call_seq=(call_seq); end

  def calls_super(); end

  def calls_super=(calls_super); end

  def dont_rename_initialize(); end

  def dont_rename_initialize=(dont_rename_initialize); end

  def marshal_dump(); end

  def marshal_load(array); end

  def param_list(); end

  def superclass_method(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::AnyMethod
end

class RDoc::Attr
  def calls_super(); end

  def definition(); end

  def initialize(text, name, rw, comment, singleton=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(array); end

  def rw(); end

  def rw=(rw); end

  def token_stream(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Attr
end

class RDoc::ClassModule
  def add_comment(comment, location); end

  def add_things(my_things, other_things); end

  def ancestors(); end

  def aref(); end

  def aref_prefix(); end

  def clear_comment(); end

  def comment_location(); end

  def comment_location=(comment_location); end

  def complete(min_visibility); end

  def constant_aliases(); end

  def constant_aliases=(constant_aliases); end

  def diagram(); end

  def diagram=(diagram); end

  def direct_ancestors(); end

  def document_self_or_methods(); end

  def find_ancestor_local_symbol(symbol); end

  def find_class_named(name); end

  def initialize(name, superclass=T.unsafe(nil)); end

  def is_alias_for(); end

  def is_alias_for=(is_alias_for); end

  def marshal_dump(); end

  def marshal_load(array); end

  def merge(class_module); end

  def merge_collections(mine, other, other_files, &block); end

  def merge_sections(cm); end

  def module?(); end

  def name=(new_name); end

  def non_aliases(); end

  def parse(comment_location); end

  def path(); end

  def remove_nodoc_children(); end

  def remove_things(my_things, other_files); end

  def search_record(); end

  def superclass(); end

  def superclass=(superclass); end

  def type(); end

  def update_aliases(); end

  def update_extends(); end

  def update_includes(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::ClassModule
  def self.from_module(class_type, mod); end
end

class RDoc::CodeObject
  include ::RDoc::Text
  include ::RDoc::Generator::Markup
  def comment(); end

  def comment=(comment); end

  def display?(); end

  def document_children(); end

  def document_children=(document_children); end

  def document_self(); end

  def document_self=(document_self); end

  def documented?(); end

  def done_documenting(); end

  def done_documenting=(value); end

  def each_parent(); end

  def file(); end

  def file_name(); end

  def force_documentation(); end

  def force_documentation=(value); end

  def full_name=(full_name); end

  def ignore(); end

  def ignored?(); end

  def initialize_visibility(); end

  def line(); end

  def line=(line); end

  def metadata(); end

  def options(); end

  def parent(); end

  def parent=(parent); end

  def parent_file_name(); end

  def parent_name(); end

  def received_nodoc(); end

  def record_location(top_level); end

  def section(); end

  def section=(section); end

  def start_doc(); end

  def stop_doc(); end

  def store(); end

  def store=(store); end

  def suppress(); end

  def suppressed?(); end

  def viewer(); end

  def viewer=(viewer); end
end

class RDoc::CodeObject
end

class RDoc::Comment
  include ::RDoc::Text
  def ==(other); end

  def document=(document); end

  def empty?(); end

  def encode!(encoding); end

  def extract_call_seq(method); end

  def file(); end

  def format(); end

  def format=(format); end

  def initialize(text=T.unsafe(nil), location=T.unsafe(nil)); end

  def location(); end

  def location=(location); end

  def normalize(); end

  def normalized?(); end

  def parse(); end

  def remove_private(); end

  def text(); end

  def text=(text); end

  def tomdoc?(); end
end

class RDoc::Comment
end

class RDoc::Constant
  def ==(other); end

  def full_name(); end

  def initialize(name, value, comment); end

  def is_alias_for(); end

  def is_alias_for=(is_alias_for); end

  def marshal_dump(); end

  def marshal_load(array); end

  def name(); end

  def name=(name); end

  def path(); end

  def value(); end

  def value=(value); end

  def visibility(); end

  def visibility=(visibility); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Constant
end

class RDoc::Context
  include ::Comparable
  def add(klass, name, comment); end

  def add_alias(an_alias); end

  def add_attribute(attribute); end

  def add_class(class_type, given_name, superclass=T.unsafe(nil)); end

  def add_class_or_module(mod, self_hash, all_hash); end

  def add_constant(constant); end

  def add_extend(ext); end

  def add_include(include); end

  def add_method(method); end

  def add_module(class_type, name); end

  def add_module_alias(from, name, file); end

  def add_require(require); end

  def add_section(title, comment=T.unsafe(nil)); end

  def add_to(array, thing); end

  def aliases(); end

  def any_content(includes=T.unsafe(nil)); end

  def attributes(); end

  def block_params(); end

  def block_params=(block_params); end

  def child_name(name); end

  def class_attributes(); end

  def class_method_list(); end

  def classes(); end

  def classes_and_modules(); end

  def classes_hash(); end

  def constants(); end

  def constants_hash(); end

  def current_line_visibility=(current_line_visibility); end

  def current_section(); end

  def current_section=(current_section); end

  def defined_in?(file); end

  def display(method_attr); end

  def each_ancestor(); end

  def each_attribute(); end

  def each_classmodule(&block); end

  def each_constant(); end

  def each_extend(); end

  def each_include(); end

  def each_method(); end

  def each_section(); end

  def extends(); end

  def external_aliases(); end

  def find_attribute(name, singleton); end

  def find_attribute_named(name); end

  def find_class_method_named(name); end

  def find_constant_named(name); end

  def find_enclosing_module_named(name); end

  def find_external_alias(name, singleton); end

  def find_external_alias_named(name); end

  def find_file_named(name); end

  def find_instance_method_named(name); end

  def find_local_symbol(symbol); end

  def find_method(name, singleton); end

  def find_method_named(name); end

  def find_module_named(name); end

  def find_symbol(symbol); end

  def find_symbol_module(symbol); end

  def full_name(); end

  def fully_documented?(); end

  def http_url(prefix); end

  def in_files(); end

  def includes(); end

  def initialize_methods_etc(); end

  def instance_attributes(); end

  def instance_method_list(); end

  def method_list(); end

  def methods_by_type(section=T.unsafe(nil)); end

  def methods_hash(); end

  def methods_matching(methods, singleton=T.unsafe(nil), &block); end

  def modules(); end

  def modules_hash(); end

  def name(); end

  def name_for_path(); end

  def ongoing_visibility=(visibility); end

  def params(); end

  def params=(params); end

  def remove_from_documentation?(); end

  def remove_invisible(min_visibility); end

  def remove_invisible_in(array, min_visibility); end

  def requires(); end

  def resolve_aliases(added); end

  def section_contents(); end

  def sections(); end

  def sections_hash(); end

  def set_constant_visibility_for(names, visibility); end

  def set_current_section(title, comment); end

  def set_visibility_for(methods, visibility, singleton=T.unsafe(nil)); end

  def sort_sections(); end

  def temporary_section(); end

  def temporary_section=(temporary_section); end

  def top_level(); end

  def unmatched_alias_lists(); end

  def unmatched_alias_lists=(unmatched_alias_lists); end

  def upgrade_to_class(mod, class_type, enclosing); end

  def visibility(); end

  def visibility=(visibility); end
  TOMDOC_TITLES = ::T.let(nil, ::T.untyped)
  TOMDOC_TITLES_SORT = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class RDoc::Context::Section
  include ::RDoc::Text
  include ::RDoc::Generator::Markup
  def ==(other); end

  def add_comment(comment); end

  def aref(); end

  def comment(); end

  def comments(); end

  def eql?(other); end

  def extract_comment(comment); end

  def in_files(); end

  def initialize(parent, title, comment); end

  def marshal_dump(); end

  def marshal_load(array); end

  def parent(); end

  def parse(); end

  def plain_html(); end

  def remove_comment(comment); end

  def sequence(); end

  def title(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Context::Section
end

class RDoc::Context
end

class RDoc::CrossReference
  def initialize(context); end

  def resolve(name, text); end

  def seen(); end

  def seen=(seen); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class RDoc::CrossReference
end

class RDoc::ERBIO
  def set_eoutvar(compiler, io_variable); end
end

class RDoc::ERBIO
end

class RDoc::ERBPartial
end

class RDoc::ERBPartial
end

module RDoc::Encoding
end

module RDoc::Encoding
  def self.change_encoding(text, encoding); end

  def self.read_file(filename, encoding, force_transcode=T.unsafe(nil)); end

  def self.remove_frozen_string_literal(string); end

  def self.set_encoding(string); end
end

class RDoc::Error
end

class RDoc::Error
end

class RDoc::Extend
end

class RDoc::Extend
end

module RDoc::Generator
end

class RDoc::Generator::Darkfish
  include ::ERB::Util
  def assemble_template(body_file); end

  def asset_rel_path(); end

  def asset_rel_path=(asset_rel_path); end

  def base_dir(); end

  def class_dir(); end

  def classes(); end

  def copy_static(); end

  def debug_msg(*msg); end

  def dry_run(); end

  def dry_run=(dry_run); end

  def file_dir(); end

  def file_output(); end

  def file_output=(file_output); end

  def files(); end

  def gen_sub_directories(); end

  def generate(); end

  def generate_class(klass, template_file=T.unsafe(nil)); end

  def generate_class_files(); end

  def generate_file_files(); end

  def generate_index(); end

  def generate_page(file); end

  def generate_servlet_not_found(message); end

  def generate_servlet_root(installed); end

  def generate_table_of_contents(); end

  def get_sorted_module_list(classes); end

  def get_svninfo(klass); end

  def initialize(store, options); end

  def install_rdoc_static_file(source, destination, options); end

  def json_index(); end

  def methods(); end

  def modsort(); end

  def outputdir(); end

  def render(file_name); end

  def render_template(template_file, out_file=T.unsafe(nil)); end

  def setup(); end

  def store(); end

  def template_dir(); end

  def template_for(file, page=T.unsafe(nil), klass=T.unsafe(nil)); end

  def template_result(template, context, template_file); end

  def time_delta_string(seconds); end

  def write_style_sheet(); end
  BUILTIN_STYLE_ITEMS = ::T.let(nil, ::T.untyped)
  DESCRIPTION = ::T.let(nil, ::T.untyped)
  GENERATOR_DIR = ::T.let(nil, ::T.untyped)
  SVNID_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::Darkfish
end

class RDoc::Generator::JsonIndex
  include ::RDoc::Text
  def build_index(); end

  def class_dir(); end

  def debug_msg(*msg); end

  def file_dir(); end

  def generate(); end

  def generate_gzipped(); end

  def index(); end

  def index_classes(); end

  def index_methods(); end

  def index_pages(); end

  def initialize(parent_generator, options); end

  def reset(files, classes); end

  def search_string(string); end
  SEARCH_INDEX_FILE = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::JsonIndex
end

module RDoc::Generator::Markup
  def aref_to(target_path); end

  def as_href(from_path); end

  def cvs_url(url, full_path); end

  def description(); end

  def formatter(); end
end

module RDoc::Generator::Markup
end

class RDoc::Generator::POT
  def class_dir(); end

  def generate(); end

  def initialize(store, options); end
  DESCRIPTION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::POT::MessageExtractor
  def extract(); end

  def initialize(store); end
end

class RDoc::Generator::POT::MessageExtractor
end

class RDoc::Generator::POT::PO
  def add(entry); end
end

class RDoc::Generator::POT::PO
end

class RDoc::Generator::POT::POEntry
  def extracted_comment(); end

  def flags(); end

  def initialize(msgid, options=T.unsafe(nil)); end

  def merge(other_entry); end

  def msgid(); end

  def msgstr(); end

  def references(); end

  def translator_comment(); end
end

class RDoc::Generator::POT::POEntry
end

class RDoc::Generator::POT
end

class RDoc::Generator::RI
  def generate(); end

  def initialize(store, options); end
  DESCRIPTION = ::T.let(nil, ::T.untyped)
end

class RDoc::Generator::RI
end

module RDoc::Generator
end

class RDoc::GhostMethod
end

class RDoc::GhostMethod
end

module RDoc::I18n
end

class RDoc::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class RDoc::I18n::Locale
  def self.[](locale_name); end

  def self.[]=(locale_name, locale); end
end

class RDoc::I18n::Text
  def extract_messages(); end

  def initialize(raw); end

  def translate(locale); end
end

class RDoc::I18n::Text
end

module RDoc::I18n
end

class RDoc::Include
end

class RDoc::Include
end

class RDoc::Markdown
  def _Alphanumeric(); end

  def _AlphanumericAscii(); end

  def _AtxHeading(); end

  def _AtxInline(); end

  def _AtxStart(); end

  def _AutoLink(); end

  def _AutoLinkEmail(); end

  def _AutoLinkUrl(); end

  def _BOM(); end

  def _BlankLine(); end

  def _Block(); end

  def _BlockQuote(); end

  def _BlockQuoteRaw(); end

  def _Bullet(); end

  def _BulletList(); end

  def _CharEntity(); end

  def _Code(); end

  def _CodeFence(); end

  def _DecEntity(); end

  def _DefinitionList(); end

  def _DefinitionListDefinition(); end

  def _DefinitionListItem(); end

  def _DefinitionListLabel(); end

  def _Digit(); end

  def _Doc(); end

  def _Emph(); end

  def _EmphStar(); end

  def _EmphUl(); end

  def _EmptyTitle(); end

  def _Endline(); end

  def _Entity(); end

  def _Enumerator(); end

  def _Eof(); end

  def _EscapedChar(); end

  def _ExplicitLink(); end

  def _ExtendedSpecialChar(); end

  def _Heading(); end

  def _HexEntity(); end

  def _HorizontalRule(); end

  def _HtmlAnchor(); end

  def _HtmlAttribute(); end

  def _HtmlBlock(); end

  def _HtmlBlockAddress(); end

  def _HtmlBlockBlockquote(); end

  def _HtmlBlockCenter(); end

  def _HtmlBlockCloseAddress(); end

  def _HtmlBlockCloseBlockquote(); end

  def _HtmlBlockCloseCenter(); end

  def _HtmlBlockCloseDd(); end

  def _HtmlBlockCloseDir(); end

  def _HtmlBlockCloseDiv(); end

  def _HtmlBlockCloseDl(); end

  def _HtmlBlockCloseDt(); end

  def _HtmlBlockCloseFieldset(); end

  def _HtmlBlockCloseForm(); end

  def _HtmlBlockCloseFrameset(); end

  def _HtmlBlockCloseH1(); end

  def _HtmlBlockCloseH2(); end

  def _HtmlBlockCloseH3(); end

  def _HtmlBlockCloseH4(); end

  def _HtmlBlockCloseH5(); end

  def _HtmlBlockCloseH6(); end

  def _HtmlBlockCloseHead(); end

  def _HtmlBlockCloseLi(); end

  def _HtmlBlockCloseMenu(); end

  def _HtmlBlockCloseNoframes(); end

  def _HtmlBlockCloseNoscript(); end

  def _HtmlBlockCloseOl(); end

  def _HtmlBlockCloseP(); end

  def _HtmlBlockClosePre(); end

  def _HtmlBlockCloseScript(); end

  def _HtmlBlockCloseTable(); end

  def _HtmlBlockCloseTbody(); end

  def _HtmlBlockCloseTd(); end

  def _HtmlBlockCloseTfoot(); end

  def _HtmlBlockCloseTh(); end

  def _HtmlBlockCloseThead(); end

  def _HtmlBlockCloseTr(); end

  def _HtmlBlockCloseUl(); end

  def _HtmlBlockDd(); end

  def _HtmlBlockDir(); end

  def _HtmlBlockDiv(); end

  def _HtmlBlockDl(); end

  def _HtmlBlockDt(); end

  def _HtmlBlockFieldset(); end

  def _HtmlBlockForm(); end

  def _HtmlBlockFrameset(); end

  def _HtmlBlockH1(); end

  def _HtmlBlockH2(); end

  def _HtmlBlockH3(); end

  def _HtmlBlockH4(); end

  def _HtmlBlockH5(); end

  def _HtmlBlockH6(); end

  def _HtmlBlockHead(); end

  def _HtmlBlockInTags(); end

  def _HtmlBlockLi(); end

  def _HtmlBlockMenu(); end

  def _HtmlBlockNoframes(); end

  def _HtmlBlockNoscript(); end

  def _HtmlBlockOl(); end

  def _HtmlBlockOpenAddress(); end

  def _HtmlBlockOpenBlockquote(); end

  def _HtmlBlockOpenCenter(); end

  def _HtmlBlockOpenDd(); end

  def _HtmlBlockOpenDir(); end

  def _HtmlBlockOpenDiv(); end

  def _HtmlBlockOpenDl(); end

  def _HtmlBlockOpenDt(); end

  def _HtmlBlockOpenFieldset(); end

  def _HtmlBlockOpenForm(); end

  def _HtmlBlockOpenFrameset(); end

  def _HtmlBlockOpenH1(); end

  def _HtmlBlockOpenH2(); end

  def _HtmlBlockOpenH3(); end

  def _HtmlBlockOpenH4(); end

  def _HtmlBlockOpenH5(); end

  def _HtmlBlockOpenH6(); end

  def _HtmlBlockOpenHead(); end

  def _HtmlBlockOpenLi(); end

  def _HtmlBlockOpenMenu(); end

  def _HtmlBlockOpenNoframes(); end

  def _HtmlBlockOpenNoscript(); end

  def _HtmlBlockOpenOl(); end

  def _HtmlBlockOpenP(); end

  def _HtmlBlockOpenPre(); end

  def _HtmlBlockOpenScript(); end

  def _HtmlBlockOpenTable(); end

  def _HtmlBlockOpenTbody(); end

  def _HtmlBlockOpenTd(); end

  def _HtmlBlockOpenTfoot(); end

  def _HtmlBlockOpenTh(); end

  def _HtmlBlockOpenThead(); end

  def _HtmlBlockOpenTr(); end

  def _HtmlBlockOpenUl(); end

  def _HtmlBlockP(); end

  def _HtmlBlockPre(); end

  def _HtmlBlockScript(); end

  def _HtmlBlockSelfClosing(); end

  def _HtmlBlockTable(); end

  def _HtmlBlockTbody(); end

  def _HtmlBlockTd(); end

  def _HtmlBlockTfoot(); end

  def _HtmlBlockTh(); end

  def _HtmlBlockThead(); end

  def _HtmlBlockTr(); end

  def _HtmlBlockType(); end

  def _HtmlBlockUl(); end

  def _HtmlCloseAnchor(); end

  def _HtmlComment(); end

  def _HtmlOpenAnchor(); end

  def _HtmlTag(); end

  def _HtmlUnclosed(); end

  def _HtmlUnclosedType(); end

  def _Image(); end

  def _InStyleTags(); end

  def _Indent(); end

  def _IndentedLine(); end

  def _Inline(); end

  def _InlineNote(); end

  def _Inlines(); end

  def _Label(); end

  def _Line(); end

  def _LineBreak(); end

  def _Link(); end

  def _ListBlock(); end

  def _ListBlockLine(); end

  def _ListContinuationBlock(); end

  def _ListItem(); end

  def _ListItemTight(); end

  def _ListLoose(); end

  def _ListTight(); end

  def _Newline(); end

  def _NonblankIndentedLine(); end

  def _NonindentSpace(); end

  def _Nonspacechar(); end

  def _NormalChar(); end

  def _NormalEndline(); end

  def _Note(); end

  def _NoteReference(); end

  def _Notes(); end

  def _OptionallyIndentedLine(); end

  def _OrderedList(); end

  def _Para(); end

  def _Plain(); end

  def _Quoted(); end

  def _RawHtml(); end

  def _RawLine(); end

  def _RawNoteBlock(); end

  def _RawNoteReference(); end

  def _RefSrc(); end

  def _RefTitle(); end

  def _RefTitleDouble(); end

  def _RefTitleParens(); end

  def _RefTitleSingle(); end

  def _Reference(); end

  def _ReferenceLink(); end

  def _ReferenceLinkDouble(); end

  def _ReferenceLinkSingle(); end

  def _References(); end

  def _SetextBottom1(); end

  def _SetextBottom2(); end

  def _SetextHeading(); end

  def _SetextHeading1(); end

  def _SetextHeading2(); end

  def _SkipBlock(); end

  def _Source(); end

  def _SourceContents(); end

  def _Sp(); end

  def _Space(); end

  def _Spacechar(); end

  def _SpecialChar(); end

  def _Spnl(); end

  def _StarLine(); end

  def _StartList(); end

  def _Str(); end

  def _StrChunk(); end

  def _Strike(); end

  def _Strong(); end

  def _StrongStar(); end

  def _StrongUl(); end

  def _StyleBlock(); end

  def _StyleClose(); end

  def _StyleOpen(); end

  def _Symbol(); end

  def _TerminalEndline(); end

  def _Ticks1(); end

  def _Ticks2(); end

  def _Ticks3(); end

  def _Ticks4(); end

  def _Ticks5(); end

  def _Title(); end

  def _TitleDouble(); end

  def _TitleSingle(); end

  def _UlLine(); end

  def _UlOrStarLine(); end

  def _Verbatim(); end

  def _VerbatimChunk(); end

  def _Whitespace(); end

  def _root(); end

  def apply(rule); end

  def apply_with_args(rule, *args); end

  def break_on_newline=(enable); end

  def break_on_newline?(); end

  def css=(enable); end

  def css?(); end

  def current_column(target=T.unsafe(nil)); end

  def current_line(target=T.unsafe(nil)); end

  def definition_lists=(enable); end

  def definition_lists?(); end

  def emphasis(text); end

  def extension(name, enable); end

  def extension?(name); end

  def external_invoke(other, rule, *args); end

  def failed_rule(); end

  def failing_rule_offset(); end

  def failure_caret(); end

  def failure_character(); end

  def failure_info(); end

  def failure_oneline(); end

  def get_byte(); end

  def get_text(start); end

  def github=(enable); end

  def github?(); end

  def grow_lr(rule, args, start_pos, m); end

  def html=(enable); end

  def html?(); end

  def initialize(extensions=T.unsafe(nil), debug=T.unsafe(nil)); end

  def inner_parse(text); end

  def lines(); end

  def link_to(content, label=T.unsafe(nil), text=T.unsafe(nil)); end

  def list_item_from(unparsed); end

  def match_string(str); end

  def note(label); end

  def note_for(ref); end

  def notes=(enable); end

  def notes?(); end

  def paragraph(parts); end

  def parse(markdown); end

  def peg_parse(rule=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def raise_error(); end

  def reference(label, link); end

  def result(); end

  def result=(result); end

  def scan(reg); end

  def set_failed_rule(name); end

  def set_string(string, pos); end

  def setup_foreign_grammar(); end

  def setup_parser(str, debug=T.unsafe(nil)); end

  def show_error(io=T.unsafe(nil)); end

  def show_pos(); end

  def strike(text); end

  def strike=(enable); end

  def strike?(); end

  def string(); end

  def strong(text); end
  DEFAULT_EXTENSIONS = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  HTML_ENTITIES = ::T.let(nil, ::T.untyped)
  Rules = ::T.let(nil, ::T.untyped)
end

class RDoc::Markdown::Literals
  def _Alphanumeric(); end

  def _AlphanumericAscii(); end

  def _BOM(); end

  def _Newline(); end

  def _NonAlphanumeric(); end

  def _Spacechar(); end

  def apply(rule); end

  def apply_with_args(rule, *args); end

  def current_column(target=T.unsafe(nil)); end

  def current_line(target=T.unsafe(nil)); end

  def external_invoke(other, rule, *args); end

  def failed_rule(); end

  def failing_rule_offset(); end

  def failure_caret(); end

  def failure_character(); end

  def failure_info(); end

  def failure_oneline(); end

  def get_byte(); end

  def get_text(start); end

  def grow_lr(rule, args, start_pos, m); end

  def initialize(str, debug=T.unsafe(nil)); end

  def lines(); end

  def match_string(str); end

  def parse(rule=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def raise_error(); end

  def result(); end

  def result=(result); end

  def scan(reg); end

  def set_failed_rule(name); end

  def set_string(string, pos); end

  def setup_foreign_grammar(); end

  def setup_parser(str, debug=T.unsafe(nil)); end

  def show_error(io=T.unsafe(nil)); end

  def show_pos(); end

  def string(); end
  Rules = ::T.let(nil, ::T.untyped)
end

class RDoc::Markdown::Literals::MemoEntry
  def ans(); end

  def initialize(ans, pos); end

  def left_rec(); end

  def left_rec=(left_rec); end

  def move!(ans, pos, result); end

  def pos(); end

  def result(); end

  def set(); end
end

class RDoc::Markdown::Literals::MemoEntry
end

class RDoc::Markdown::Literals::ParseError
end

class RDoc::Markdown::Literals::ParseError
end

class RDoc::Markdown::Literals::RuleInfo
  def initialize(name, rendered); end

  def name(); end

  def rendered(); end
end

class RDoc::Markdown::Literals::RuleInfo
end

class RDoc::Markdown::Literals
  def self.rule_info(name, rendered); end
end

class RDoc::Markdown::MemoEntry
  def ans(); end

  def initialize(ans, pos); end

  def left_rec(); end

  def left_rec=(left_rec); end

  def move!(ans, pos, result); end

  def pos(); end

  def result(); end

  def set(); end
end

class RDoc::Markdown::MemoEntry
end

class RDoc::Markdown::ParseError
end

class RDoc::Markdown::ParseError
end

class RDoc::Markdown::RuleInfo
  def initialize(name, rendered); end

  def name(); end

  def rendered(); end
end

class RDoc::Markdown::RuleInfo
end

class RDoc::Markdown
  def self.extension(name); end

  def self.parse(markdown); end

  def self.rule_info(name, rendered); end
end

class RDoc::Markup
  def add_html(tag, name); end

  def add_special(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute_manager(); end

  def convert(input, formatter); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class RDoc::Markup::AttrChanger
  def turn_off(); end

  def turn_off=(_); end

  def turn_on(); end

  def turn_on=(_); end
end

class RDoc::Markup::AttrChanger
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Markup::AttrSpan
  def [](n); end

  def initialize(length); end

  def set_attrs(start, length, bits); end
end

class RDoc::Markup::AttrSpan
end

class RDoc::Markup::AttributeManager
  def add_html(tag, name); end

  def add_special(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute(turn_on, turn_off); end

  def attributes(); end

  def change_attribute(current, new); end

  def changed_attribute_by_name(current_set, new_set); end

  def convert_attrs(str, attrs); end

  def convert_html(str, attrs); end

  def convert_specials(str, attrs); end

  def copy_string(start_pos, end_pos); end

  def display_attributes(); end

  def flow(str); end

  def html_tags(); end

  def mask_protected_sequences(); end

  def matching_word_pairs(); end

  def protectable(); end

  def special(); end

  def split_into_flow(); end

  def unmask_protected_sequences(); end

  def word_pair_map(); end
  A_PROTECT = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  PROTECT_ATTR = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::AttributeManager
end

class RDoc::Markup::Attributes
  def as_string(bitmap); end

  def bitmap_for(name); end

  def each_name_of(bitmap); end

  def special(); end
end

class RDoc::Markup::Attributes
end

class RDoc::Markup::BlankLine
  def accept(visitor); end
end

class RDoc::Markup::BlankLine
  def self.new(); end
end

class RDoc::Markup::BlockQuote
end

class RDoc::Markup::BlockQuote
end

class RDoc::Markup::Document
  include ::Enumerable
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def concat(parts); end

  def each(&block); end

  def empty?(); end

  def file(); end

  def file=(location); end

  def initialize(*parts); end

  def merge(other); end

  def merged?(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def parts(); end

  def push(*parts); end

  def table_of_contents(); end
end

class RDoc::Markup::Document
end

class RDoc::Markup::Formatter
  def accept_document(document); end

  def add_special_RDOCLINK(); end

  def add_special_TIDYLINK(); end

  def add_tag(name, start, stop); end

  def annotate(tag); end

  def convert(content); end

  def convert_flow(flow); end

  def convert_special(special); end

  def convert_string(string); end

  def ignore(*node); end

  def in_tt?(); end

  def initialize(options, markup=T.unsafe(nil)); end

  def off_tags(res, item); end

  def on_tags(res, item); end

  def parse_url(url); end

  def tt?(tag); end
end

class RDoc::Markup::Formatter::InlineTag
  def bit(); end

  def bit=(_); end

  def off(); end

  def off=(_); end

  def on(); end

  def on=(_); end
end

class RDoc::Markup::Formatter::InlineTag
  def self.[](*_); end

  def self.members(); end
end

class RDoc::Markup::Formatter
  def self.gen_relative_url(path, target); end
end

class RDoc::Markup::HardBreak
  def ==(other); end

  def accept(visitor); end
end

class RDoc::Markup::HardBreak
  def self.new(); end
end

class RDoc::Markup::Heading
  def accept(visitor); end

  def aref(); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def level=(_); end

  def plain_html(); end

  def text(); end

  def text=(_); end
end

class RDoc::Markup::Heading
  def self.[](*_); end

  def self.members(); end

  def self.to_html(); end

  def self.to_label(); end
end

class RDoc::Markup::Include
  def ==(other); end

  def file(); end

  def include_path(); end

  def initialize(file, include_path); end
end

class RDoc::Markup::Include
end

class RDoc::Markup::IndentedParagraph
  def indent(); end

  def initialize(indent, *parts); end

  def text(hard_break=T.unsafe(nil)); end
end

class RDoc::Markup::IndentedParagraph
end

class RDoc::Markup::List
  def <<(item); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(type=T.unsafe(nil), *items); end

  def items(); end

  def last(); end

  def push(*items); end

  def type(); end

  def type=(type); end
end

class RDoc::Markup::List
end

class RDoc::Markup::ListItem
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(label=T.unsafe(nil), *parts); end

  def label(); end

  def label=(label); end

  def length(); end

  def parts(); end

  def push(*parts); end
end

class RDoc::Markup::ListItem
end

class RDoc::Markup::Paragraph
  def text(hard_break=T.unsafe(nil)); end
end

class RDoc::Markup::Paragraph
end

class RDoc::Markup::Parser
  include ::RDoc::Text
  def build_heading(level); end

  def build_list(margin); end

  def build_paragraph(margin); end

  def build_verbatim(margin); end

  def char_pos(byte_offset); end

  def debug(); end

  def debug=(debug); end

  def get(); end

  def parse(parent, indent=T.unsafe(nil)); end

  def parse_text(parent, indent); end

  def peek_token(); end

  def setup_scanner(input); end

  def skip(token_type, error=T.unsafe(nil)); end

  def token_pos(byte_offset); end

  def tokenize(input); end

  def tokens(); end

  def unget(); end
  LIST_TOKENS = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::Parser::Error
end

class RDoc::Markup::Parser::Error
end

class RDoc::Markup::Parser::ParseError
end

class RDoc::Markup::Parser::ParseError
end

class RDoc::Markup::Parser
  def self.parse(str); end

  def self.tokenize(str); end
end

class RDoc::Markup::PreProcess
  def find_include_file(name); end

  def handle(text, code_object=T.unsafe(nil), &block); end

  def handle_directive(prefix, directive, param, code_object=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def include_file(name, indent, encoding); end

  def initialize(input_file_name, include_path); end

  def options(); end

  def options=(options); end
end

class RDoc::Markup::PreProcess
  def self.post_process(&block); end

  def self.post_processors(); end

  def self.register(directive, &block); end

  def self.registered(); end

  def self.reset(); end
end

class RDoc::Markup::Raw
  def <<(text); end

  def ==(other); end

  def accept(visitor); end

  def initialize(*parts); end

  def merge(other); end

  def parts(); end

  def push(*texts); end

  def text(); end
end

class RDoc::Markup::Raw
end

class RDoc::Markup::Rule
  def accept(visitor); end
end

class RDoc::Markup::Rule
end

class RDoc::Markup::Special
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class RDoc::Markup::Special
end

class RDoc::Markup::ToAnsi
end

class RDoc::Markup::ToAnsi
end

class RDoc::Markup::ToBs
end

class RDoc::Markup::ToBs
end

class RDoc::Markup::ToHtml
  include ::RDoc::Text
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def code_object(); end

  def code_object=(code_object); end

  def convert_string(text); end

  def end_accepting(); end

  def from_path(); end

  def from_path=(from_path); end

  def gen_url(url, text); end

  def handle_RDOCLINK(url); end

  def handle_special_HARD_BREAK(special); end

  def handle_special_HYPERLINK(special); end

  def handle_special_RDOCLINK(special); end

  def handle_special_TIDYLINK(special); end

  def html_list_name(list_type, open_tag); end

  def in_list_entry(); end

  def init_tags(); end

  def list(); end

  def list_end_for(list_type); end

  def list_item_start(list_item, list_type); end

  def parseable?(text); end

  def res(); end

  def start_accepting(); end

  def to_html(item); end
  LIST_TYPE_TO_HTML = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::ToHtml
end

class RDoc::Markup::ToHtmlCrossref
  def context(); end

  def context=(context); end

  def cross_reference(name, text=T.unsafe(nil)); end

  def handle_special_CROSSREF(special); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end

  def link(name, text); end

  def show_hash(); end

  def show_hash=(show_hash); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::ToHtmlCrossref
end

class RDoc::Markup::ToHtmlSnippet
  def accept_raw(*node); end

  def accept_rule(*node); end

  def add_paragraph(); end

  def character_limit(); end

  def characters(); end

  def handle_special_CROSSREF(special); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end

  def mask(); end

  def paragraph_limit(); end

  def paragraphs(); end

  def truncate(text); end
end

class RDoc::Markup::ToHtmlSnippet
end

class RDoc::Markup::ToJoinedParagraph
  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(paragraph); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def start_accepting(); end
end

class RDoc::Markup::ToJoinedParagraph
end

class RDoc::Markup::ToLabel
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def convert(text); end

  def end_accepting(*node); end

  def handle_special_CROSSREF(special); end

  def handle_special_HARD_BREAK(*node); end

  def handle_special_TIDYLINK(special); end

  def initialize(markup=T.unsafe(nil)); end

  def res(); end

  def start_accepting(*node); end
end

class RDoc::Markup::ToLabel
end

class RDoc::Markup::ToMarkdown
  def gen_url(url, text); end

  def handle_rdoc_link(url); end

  def handle_special_RDOCLINK(special); end

  def handle_special_TIDYLINK(special); end
end

class RDoc::Markup::ToMarkdown
end

class RDoc::Markup::ToRdoc
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_indented_paragraph(paragraph); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def attributes(text); end

  def end_accepting(); end

  def handle_special_HARD_BREAK(special); end

  def handle_special_SUPPRESSED_CROSSREF(special); end

  def indent(); end

  def indent=(indent); end

  def init_tags(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_index(); end

  def list_type(); end

  def list_width(); end

  def prefix(); end

  def res(); end

  def start_accepting(); end

  def use_prefix(); end

  def width(); end

  def width=(width); end

  def wrap(text); end
end

class RDoc::Markup::ToRdoc
end

class RDoc::Markup::ToTableOfContents
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(heading); end

  def accept_list_end(*node); end

  def accept_list_end_bullet(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def res(); end

  def start_accepting(); end

  def suppressed?(heading); end
end

class RDoc::Markup::ToTableOfContents
  def self.to_toc(); end
end

class RDoc::Markup::ToTest
  def accept_blank_line(blank_line); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def end_accepting(); end

  def start_accepting(); end
end

class RDoc::Markup::ToTest
end

class RDoc::Markup::ToTtOnly
  def accept_blank_line(markup_item); end

  def accept_block_quote(block_quote); end

  def accept_heading(markup_item); end

  def accept_list_end(list); end

  def accept_list_item_end(markup_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(markup_item); end

  def accept_rule(markup_item); end

  def accept_verbatim(markup_item); end

  def do_nothing(markup_item); end

  def end_accepting(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_type(); end

  def res(); end

  def start_accepting(); end

  def tt_sections(text); end
end

class RDoc::Markup::ToTtOnly
end

class RDoc::Markup::Verbatim
  def format(); end

  def format=(format); end

  def normalize(); end

  def ruby?(); end
end

class RDoc::Markup::Verbatim
end

class RDoc::Markup
  def self.parse(str); end
end

class RDoc::MetaMethod
end

class RDoc::MetaMethod
end

class RDoc::MethodAttr
  include ::Comparable
  def ==(other); end

  def add_alias(an_alias, context); end

  def add_line_numbers(src); end

  def aliases(); end

  def aref(); end

  def aref_prefix(); end

  def arglists(); end

  def block_params(); end

  def block_params=(value); end

  def call_seq(); end

  def call_seq=(call_seq); end

  def find_method_or_attribute(name); end

  def find_see(); end

  def full_name(); end

  def html_name(); end

  def initialize(text, name); end

  def is_alias_for(); end

  def is_alias_for=(is_alias_for); end

  def markup_code(); end

  def name(); end

  def name=(name); end

  def name_prefix(); end

  def output_name(context); end

  def param_seq(); end

  def params(); end

  def params=(params); end

  def path(); end

  def pretty_name(); end

  def search_record(); end

  def see(); end

  def singleton(); end

  def singleton=(singleton); end

  def text(); end

  def type(); end

  def visibility(); end

  def visibility=(visibility); end
end

class RDoc::MethodAttr
  def self.add_line_numbers(); end

  def self.add_line_numbers=(add_line_numbers); end
end

class RDoc::Mixin
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, comment); end

  def module(); end

  def name(); end

  def name=(name); end
end

class RDoc::Mixin
end

class RDoc::NormalClass
  def definition(); end
end

class RDoc::NormalClass
end

class RDoc::NormalModule
  def definition(); end
end

class RDoc::NormalModule
end

class RDoc::Options
  def ==(other); end

  def charset(); end

  def charset=(charset); end

  def check_files(); end

  def check_generator(); end

  def coverage_report(); end

  def coverage_report=(coverage_report); end

  def default_title=(string); end

  def dry_run(); end

  def dry_run=(dry_run); end

  def encode_with(coder); end

  def encoding(); end

  def encoding=(encoding); end

  def exclude(); end

  def exclude=(exclude); end

  def files(); end

  def files=(files); end

  def finish(); end

  def finish_page_dir(); end

  def force_output(); end

  def force_output=(force_output); end

  def force_update(); end

  def force_update=(force_update); end

  def formatter(); end

  def formatter=(formatter); end

  def generator(); end

  def generator=(generator); end

  def generator_descriptions(); end

  def generator_name(); end

  def generator_options(); end

  def generator_options=(generator_options); end

  def hyperlink_all(); end

  def hyperlink_all=(hyperlink_all); end

  def init_ivars(); end

  def init_with(map); end

  def line_numbers(); end

  def line_numbers=(line_numbers); end

  def locale(); end

  def locale=(locale); end

  def locale_dir(); end

  def locale_dir=(locale_dir); end

  def main_page(); end

  def main_page=(main_page); end

  def markup(); end

  def markup=(markup); end

  def op_dir(); end

  def op_dir=(op_dir); end

  def option_parser(); end

  def option_parser=(option_parser); end

  def output_decoration(); end

  def output_decoration=(output_decoration); end

  def page_dir(); end

  def page_dir=(page_dir); end

  def parse(argv); end

  def pipe(); end

  def pipe=(pipe); end

  def quiet(); end

  def quiet=(bool); end

  def rdoc_include(); end

  def rdoc_include=(rdoc_include); end

  def root(); end

  def root=(root); end

  def sanitize_path(path); end

  def setup_generator(generator_name=T.unsafe(nil)); end

  def show_hash(); end

  def show_hash=(show_hash); end

  def static_path(); end

  def static_path=(static_path); end

  def tab_width(); end

  def tab_width=(tab_width); end

  def template(); end

  def template=(template); end

  def template_dir(); end

  def template_dir=(template_dir); end

  def template_dir_for(template); end

  def template_stylesheets(); end

  def template_stylesheets=(template_stylesheets); end

  def title(); end

  def title=(title); end

  def update_output_dir(); end

  def update_output_dir=(update_output_dir); end

  def verbosity(); end

  def verbosity=(verbosity); end

  def visibility(); end

  def visibility=(visibility); end

  def warn(message); end

  def webcvs(); end

  def webcvs=(webcvs); end

  def write_options(); end

  def yaml_initialize(tag, map); end
  DEPRECATED = ::T.let(nil, ::T.untyped)
  Directory = ::T.let(nil, ::T.untyped)
  Path = ::T.let(nil, ::T.untyped)
  PathArray = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  Template = ::T.let(nil, ::T.untyped)
end

class RDoc::Options
end

class RDoc::Parser
  def file_name(); end

  def initialize(top_level, file_name, content, options, stats); end
end

class RDoc::Parser::C
  include ::RDoc::Text
  def classes(); end

  def content(); end

  def content=(content); end

  def deduplicate_call_seq(); end

  def deduplicate_method_name(class_obj, method_name); end

  def do_aliases(); end

  def do_attrs(); end

  def do_boot_defclass(); end

  def do_classes(); end

  def do_constants(); end

  def do_define_class(); end

  def do_define_class_under(); end

  def do_define_module(); end

  def do_define_module_under(); end

  def do_includes(); end

  def do_methods(); end

  def do_missing(); end

  def do_modules(); end

  def do_singleton_class(); end

  def do_struct_define_without_accessor(); end

  def enclosure_dependencies(); end

  def find_alias_comment(class_name, new_name, old_name); end

  def find_attr_comment(var_name, attr_name, read=T.unsafe(nil), write=T.unsafe(nil)); end

  def find_body(class_name, meth_name, meth_obj, file_content, quiet=T.unsafe(nil)); end

  def find_class(raw_name, name); end

  def find_class_comment(class_name, class_mod); end

  def find_const_comment(type, const_name, class_name=T.unsafe(nil)); end

  def find_modifiers(comment, meth_obj); end

  def find_override_comment(class_name, meth_obj); end

  def gen_body_table(file_content); end

  def gen_const_table(file_content); end

  def handle_attr(var_name, attr_name, read, write); end

  def handle_class_module(var_name, type, class_name, parent, in_module); end

  def handle_constants(type, var_name, const_name, definition); end

  def handle_ifdefs_in(body); end

  def handle_method(type, var_name, meth_name, function, param_count, source_file=T.unsafe(nil)); end

  def handle_singleton(sclass_var, class_var); end

  def handle_tab_width(body); end

  def known_classes(); end

  def load_variable_map(map_name); end

  def look_for_directives_in(context, comment); end

  def missing_dependencies(); end

  def rb_scan_args(method_body); end

  def remove_commented_out_lines(); end

  def scan(); end

  def singleton_classes(); end

  def top_level(); end
end

class RDoc::Parser::C
end

class RDoc::Parser::ChangeLog
  include ::RDoc::Parser::Text
  def continue_entry_body(entry_body, continuation); end

  def create_document(groups); end

  def create_entries(entries); end

  def create_items(items); end

  def group_entries(entries); end

  def parse_entries(); end

  def scan(); end
end

class RDoc::Parser::ChangeLog
end

class RDoc::Parser::Markdown
  include ::RDoc::Parser::Text
  def scan(); end
end

class RDoc::Parser::Markdown
end

class RDoc::Parser::RD
  include ::RDoc::Parser::Text
  def scan(); end
end

class RDoc::Parser::RD
end

class RDoc::Parser::Ruby
  include ::RDoc::TokenStream
  include ::RDoc::Parser::RubyTools
  def collect_first_comment(); end

  def consume_trailing_spaces(); end

  def create_attr(container, single, name, rw, comment); end

  def create_module_alias(container, constant, rhs_name); end

  def error(msg); end

  def get_bool(); end

  def get_class_or_module(container, ignore_constants=T.unsafe(nil)); end

  def get_class_specification(); end

  def get_constant(); end

  def get_constant_with_optional_parens(); end

  def get_end_token(tk); end

  def get_method_container(container, name_t); end

  def get_symbol_or_name(); end

  def get_tkread_clean(pattern, replacement); end

  def get_visibility_information(tk, single); end

  def look_for_directives_in(container, comment); end

  def make_message(message); end

  def new_comment(comment); end

  def parse_alias(context, single, tk, comment); end

  def parse_attr(context, single, tk, comment); end

  def parse_attr_accessor(context, single, tk, comment); end

  def parse_call_parameters(tk); end

  def parse_class(container, single, tk, comment); end

  def parse_class_regular(container, declaration_context, single, name_t, given_name, comment); end

  def parse_class_singleton(container, name, comment); end

  def parse_comment(container, tk, comment); end

  def parse_comment_attr(container, type, name, comment); end

  def parse_comment_ghost(container, text, name, column, line_no, comment); end

  def parse_comment_tomdoc(container, tk, comment); end

  def parse_constant(container, tk, comment, ignore_constants=T.unsafe(nil)); end

  def parse_constant_body(container, constant, is_array_or_hash); end

  def parse_constant_visibility(container, single, tk); end

  def parse_extend_or_include(klass, container, comment); end

  def parse_identifier(container, single, tk, comment); end

  def parse_meta_attr(context, single, tk, comment); end

  def parse_meta_method(container, single, tk, comment); end

  def parse_meta_method_name(comment, tk); end

  def parse_meta_method_params(container, single, meth, tk, comment); end

  def parse_method(container, single, tk, comment); end

  def parse_method_dummy(container); end

  def parse_method_name(container); end

  def parse_method_name_regular(container, name_t); end

  def parse_method_name_singleton(container, name_t); end

  def parse_method_or_yield_parameters(method=T.unsafe(nil), modifiers=T.unsafe(nil)); end

  def parse_method_parameters(method); end

  def parse_method_params_and_body(container, single, meth, added_container); end

  def parse_module(container, single, tk, comment); end

  def parse_require(context, comment); end

  def parse_rescue(); end

  def parse_statements(container, single=T.unsafe(nil), current_method=T.unsafe(nil), comment=T.unsafe(nil)); end

  def parse_symbol_arg(no=T.unsafe(nil)); end

  def parse_symbol_arg_paren(no); end

  def parse_symbol_arg_space(no, tk); end

  def parse_symbol_in_arg(); end

  def parse_top_level_statements(container); end

  def parse_visibility(container, single, tk); end

  def parse_yield(context, single, tk, method); end

  def read_directive(allowed); end

  def read_documentation_modifiers(context, allowed); end

  def record_location(container); end

  def scan(); end

  def skip_for_variable(); end

  def skip_method(container); end

  def skip_optional_do_after_expression(); end

  def skip_tkspace_comment(skip_nl=T.unsafe(nil)); end

  def suppress_parents(container, ancestor); end

  def update_visibility(container, vis_type, vis, singleton); end

  def warn(message); end
  NORMAL = ::T.let(nil, ::T.untyped)
  SINGLE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::Ruby
end

module RDoc::Parser::RubyTools
  def add_token_listener(obj); end

  def get_tk(); end

  def get_tk_until(*tokens); end

  def get_tkread(); end

  def peek_read(); end

  def peek_tk(); end

  def remove_token_listener(obj); end

  def reset(); end

  def skip_tkspace(skip_nl=T.unsafe(nil)); end

  def tk_nl?(tk); end

  def token_listener(obj); end

  def unget_tk(tk); end
end

module RDoc::Parser::RubyTools
end

class RDoc::Parser::Simple
  include ::RDoc::Parser::Text
  def content(); end

  def remove_coding_comment(text); end

  def remove_private_comment(comment); end

  def scan(); end
end

class RDoc::Parser::Simple
end

module RDoc::Parser::Text
end

module RDoc::Parser::Text
end

class RDoc::Parser
  def self.alias_extension(old_ext, new_ext); end

  def self.binary?(file); end

  def self.can_parse(file_name); end

  def self.can_parse_by_name(file_name); end

  def self.check_modeline(file_name); end

  def self.for(top_level, file_name, content, options, stats); end

  def self.parse_files_matching(regexp); end

  def self.parsers(); end

  def self.remove_modeline(content); end

  def self.use_markup(content); end

  def self.zip?(file); end
end

class RDoc::RD
end

class RDoc::RD::BlockParser
  def _reduce_1(val, _values, result); end

  def _reduce_10(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_54(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def add_footnote(content); end

  def add_label(label); end

  def content(values); end

  def footnotes(); end

  def include_path(); end

  def include_path=(include_path); end

  def labels(); end

  def line_index(); end

  def on_error(et, ev, _values); end

  def paragraph(value); end

  def parse(src); end
  MARK_TO_LEVEL = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
  TMPFILE = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::BlockParser
end

class RDoc::RD::Inline
  def ==(other); end

  def append(more); end

  def initialize(rdoc, reference); end

  def rdoc(); end

  def reference(); end
end

class RDoc::RD::Inline
  def self.new(rdoc, reference=T.unsafe(nil)); end
end

class RDoc::RD::InlineParser
  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_109(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(block_parser); end

  def inline(rdoc, reference=T.unsafe(nil)); end

  def next_words_on_error(); end

  def on_error(et, ev, values); end

  def parse(inline); end

  def prev_words_on_error(ev); end
  BACK_SLASH = ::T.let(nil, ::T.untyped)
  BACK_SLASH_RE = ::T.let(nil, ::T.untyped)
  BAR = ::T.let(nil, ::T.untyped)
  BAR_RE = ::T.let(nil, ::T.untyped)
  CODE_CLOSE = ::T.let(nil, ::T.untyped)
  CODE_CLOSE_RE = ::T.let(nil, ::T.untyped)
  CODE_OPEN = ::T.let(nil, ::T.untyped)
  CODE_OPEN_RE = ::T.let(nil, ::T.untyped)
  EM_CLOSE = ::T.let(nil, ::T.untyped)
  EM_CLOSE_RE = ::T.let(nil, ::T.untyped)
  EM_OPEN = ::T.let(nil, ::T.untyped)
  EM_OPEN_RE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_CLOSE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_CLOSE_RE = ::T.let(nil, ::T.untyped)
  FOOTNOTE_OPEN = ::T.let(nil, ::T.untyped)
  FOOTNOTE_OPEN_RE = ::T.let(nil, ::T.untyped)
  INDEX_CLOSE = ::T.let(nil, ::T.untyped)
  INDEX_CLOSE_RE = ::T.let(nil, ::T.untyped)
  INDEX_OPEN = ::T.let(nil, ::T.untyped)
  INDEX_OPEN_RE = ::T.let(nil, ::T.untyped)
  KBD_CLOSE = ::T.let(nil, ::T.untyped)
  KBD_CLOSE_RE = ::T.let(nil, ::T.untyped)
  KBD_OPEN = ::T.let(nil, ::T.untyped)
  KBD_OPEN_RE = ::T.let(nil, ::T.untyped)
  OTHER_RE = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  QUOTE_RE = ::T.let(nil, ::T.untyped)
  REF_CLOSE = ::T.let(nil, ::T.untyped)
  REF_CLOSE_RE = ::T.let(nil, ::T.untyped)
  REF_OPEN = ::T.let(nil, ::T.untyped)
  REF_OPEN_RE = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  SLASH_RE = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
  URL_RE = ::T.let(nil, ::T.untyped)
  VAR_CLOSE = ::T.let(nil, ::T.untyped)
  VAR_CLOSE_RE = ::T.let(nil, ::T.untyped)
  VAR_OPEN = ::T.let(nil, ::T.untyped)
  VAR_OPEN_RE = ::T.let(nil, ::T.untyped)
  VERB_CLOSE = ::T.let(nil, ::T.untyped)
  VERB_CLOSE_RE = ::T.let(nil, ::T.untyped)
  VERB_OPEN = ::T.let(nil, ::T.untyped)
  VERB_OPEN_RE = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::InlineParser
end

class RDoc::RD
  def self.parse(rd); end
end

class RDoc::RDoc
  def document(options); end

  def error(msg); end

  def exclude(); end

  def exclude=(exclude); end

  def gather_files(files); end

  def generate(); end

  def generator(); end

  def generator=(generator); end

  def handle_pipe(); end

  def install_siginfo_handler(); end

  def last_modified(); end

  def list_files_in_directory(dir); end

  def load_options(); end

  def normalized_file_list(relative_files, force_doc=T.unsafe(nil), exclude_pattern=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output_flag_file(op_dir); end

  def parse_dot_doc_file(in_dir, filename); end

  def parse_file(filename); end

  def parse_files(files); end

  def remove_siginfo_handler(); end

  def remove_unparseable(files); end

  def setup_output_dir(dir, force); end

  def stats(); end

  def store(); end

  def store=(store); end

  def update_output_dir(op_dir, time, last=T.unsafe(nil)); end
  GENERATORS = ::T.let(nil, ::T.untyped)
end

class RDoc::RDoc
  def self.add_generator(klass); end

  def self.current(); end

  def self.current=(rdoc); end
end

module RDoc::RI
end

class RDoc::RI::Driver
  def add_also_in(out, also_in); end

  def add_class(out, name, classes); end

  def add_extends(out, extends); end

  def add_extension_modules(out, type, extensions); end

  def add_extension_modules_multiple(out, store, modules); end

  def add_extension_modules_single(out, store, include); end

  def add_from(out, store); end

  def add_includes(out, includes); end

  def add_method(out, name); end

  def add_method_documentation(out, klass); end

  def add_method_list(out, methods, name); end

  def ancestors_of(klass); end

  def check_did_you_mean(); end

  def class_cache(); end

  def class_document(name, found, klasses, includes, extends); end

  def class_document_comment(out, comment); end

  def class_document_constants(out, klass); end

  def classes(); end

  def classes_and_includes_and_extends_for(name); end

  def complete(name); end

  def complete_klass(name, klass, selector, method, completions); end

  def complete_method(name, klass, selector, completions); end

  def display(document); end

  def display_class(name); end

  def display_method(name); end

  def display_name(name); end

  def display_names(names); end

  def display_page(name); end

  def display_page_list(store, pages=T.unsafe(nil), search=T.unsafe(nil)); end

  def expand_class(klass); end

  def expand_name(name); end

  def filter_methods(found, name); end

  def find_methods(name); end

  def find_pager_jruby(pager); end

  def find_store(name); end

  def formatter(io); end

  def in_path?(file); end

  def initialize(initial_options=T.unsafe(nil)); end

  def interactive(); end

  def list_known_classes(names=T.unsafe(nil)); end

  def list_methods_matching(name); end

  def load_method(store, cache, klass, type, name); end

  def load_methods_matching(name); end

  def lookup_method(name); end

  def method_document(name, filtered); end

  def method_type(selector); end

  def name_regexp(name); end

  def page(); end

  def paging?(); end

  def parse_name(name); end

  def render_class(out, store, klass, also_in); end

  def render_method(out, store, method, name); end

  def render_method_arguments(out, arglists); end

  def render_method_comment(out, method); end

  def render_method_superclass(out, method); end

  def run(); end

  def setup_pager(); end

  def show_all(); end

  def show_all=(show_all); end

  def start_server(); end

  def stores(); end

  def stores=(stores); end

  def use_stdout(); end

  def use_stdout=(use_stdout); end
end

class RDoc::RI::Driver::Error
end

class RDoc::RI::Driver::Error
end

class RDoc::RI::Driver::NotFoundError
  def initialize(klass, suggestions=T.unsafe(nil)); end

  def name(); end
end

class RDoc::RI::Driver::NotFoundError
end

class RDoc::RI::Driver
  def self.default_options(); end

  def self.dump(data_path); end

  def self.process_args(argv); end

  def self.run(argv=T.unsafe(nil)); end
end

class RDoc::RI::Error
end

class RDoc::RI::Error
end

module RDoc::RI::Paths
  BASE = ::T.let(nil, ::T.untyped)
  HOMEDIR = ::T.let(nil, ::T.untyped)
end

module RDoc::RI::Paths
  def self.each(system=T.unsafe(nil), site=T.unsafe(nil), home=T.unsafe(nil), gems=T.unsafe(nil), *extra_dirs, &blk); end

  def self.gem_dir(name, version); end

  def self.gemdirs(filter=T.unsafe(nil)); end

  def self.home_dir(); end

  def self.path(system=T.unsafe(nil), site=T.unsafe(nil), home=T.unsafe(nil), gems=T.unsafe(nil), *extra_dirs); end

  def self.raw_path(system, site, home, gems, *extra_dirs); end

  def self.site_dir(); end

  def self.system_dir(); end
end

RDoc::RI::Store = RDoc::Store

module RDoc::RI
end

class RDoc::Require
  def initialize(name, comment); end

  def name(); end

  def name=(name); end

  def top_level(); end
end

class RDoc::Require
end

class RDoc::RipperStateLex
  def get_squashed_tk(); end

  def initialize(code); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  RIPPER_HAS_LEX_STATE = ::T.let(nil, ::T.untyped)
end

class RDoc::RipperStateLex::InnerStateLex
  def each(&block); end

  def initialize(code); end

  def on_default(event, tok, data); end
end

class RDoc::RipperStateLex::InnerStateLex
end

class RDoc::RipperStateLex
  def self.end?(token); end

  def self.parse(code); end
end

class RDoc::Servlet
  def asset(generator_name, req, res); end

  def asset_dirs(); end

  def documentation_page(store, generator, path, req, res); end

  def documentation_search(store, generator, req, res); end

  def documentation_source(path); end

  def error(exception, req, res); end

  def generator_for(store); end

  def if_modified_since(req, res, path=T.unsafe(nil)); end

  def initialize(server, stores, cache, mount_path=T.unsafe(nil), extra_doc_dirs=T.unsafe(nil)); end

  def installed_docs(); end

  def not_found(generator, req, res, message=T.unsafe(nil)); end

  def options(); end

  def ri_paths(&block); end

  def root(req, res); end

  def root_search(req, res); end

  def show_documentation(req, res); end

  def store_for(source_name); end
end

class RDoc::Servlet
end

class RDoc::SingleClass
  def definition(); end
end

class RDoc::SingleClass
end

class RDoc::Stats
  include ::RDoc::Text
  def add_alias(as); end

  def add_attribute(attribute); end

  def add_class(klass); end

  def add_constant(constant); end

  def add_file(file); end

  def add_method(method); end

  def add_module(mod); end

  def begin_adding(); end

  def calculate(); end

  def coverage_level(); end

  def coverage_level=(level); end

  def doc_stats(collection); end

  def done_adding(); end

  def files_so_far(); end

  def fully_documented?(); end

  def great_job(); end

  def initialize(store, num_files, verbosity=T.unsafe(nil)); end

  def num_files(); end

  def percent_doc(); end

  def report(); end

  def report_attributes(cm); end

  def report_class_module(cm); end

  def report_constants(cm); end

  def report_methods(cm); end

  def summary(); end

  def undoc_params(method); end
end

class RDoc::Stats::Normal
  def begin_adding(); end

  def done_adding(); end

  def print_file(files_so_far, filename); end
end

class RDoc::Stats::Normal
end

class RDoc::Stats::Quiet
  def begin_adding(*_); end

  def done_adding(*_); end

  def initialize(num_files); end

  def print_alias(*_); end

  def print_attribute(*_); end

  def print_class(*_); end

  def print_constant(*_); end

  def print_file(*_); end

  def print_method(*_); end

  def print_module(*_); end
end

class RDoc::Stats::Quiet
end

class RDoc::Stats::Verbose
  def nodoc(co); end

  def print_alias(as); end

  def print_attribute(attribute); end

  def print_class(klass); end

  def print_constant(constant); end

  def print_file(files_so_far, file); end

  def print_method(method); end

  def print_module(mod); end
end

class RDoc::Stats::Verbose
end

class RDoc::Stats
end

class RDoc::Store
  def add_c_enclosure(variable, namespace); end

  def add_c_variables(c_parser); end

  def add_file(absolute_name, relative_name=T.unsafe(nil)); end

  def all_classes(); end

  def all_classes_and_modules(); end

  def all_files(); end

  def all_modules(); end

  def ancestors(); end

  def attributes(); end

  def c_class_variables(); end

  def c_enclosure_classes(); end

  def c_enclosure_names(); end

  def c_singleton_class_variables(); end

  def cache(); end

  def cache_path(); end

  def class_file(klass_name); end

  def class_methods(); end

  def class_path(klass_name); end

  def classes_hash(); end

  def clean_cache_collection(collection); end

  def complete(min_visibility); end

  def dry_run(); end

  def dry_run=(dry_run); end

  def encoding(); end

  def encoding=(encoding); end

  def files_hash(); end

  def find_c_enclosure(variable); end

  def find_class_named(name); end

  def find_class_named_from(name, from); end

  def find_class_or_module(name); end

  def find_file_named(name); end

  def find_module_named(name); end

  def find_text_page(file_name); end

  def find_unique(all_hash); end

  def fix_basic_object_inheritance(); end

  def friendly_path(); end

  def initialize(path=T.unsafe(nil), type=T.unsafe(nil)); end

  def instance_methods(); end

  def load_all(); end

  def load_cache(); end

  def load_class(klass_name); end

  def load_class_data(klass_name); end

  def load_method(klass_name, method_name); end

  def load_page(page_name); end

  def main(); end

  def main=(page); end

  def make_variable_map(variables); end

  def method_file(klass_name, method_name); end

  def module_names(); end

  def modules_hash(); end

  def page(name); end

  def page_file(page_name); end

  def path(); end

  def path=(path); end

  def rdoc(); end

  def rdoc=(rdoc); end

  def remove_nodoc(all_hash); end

  def save(); end

  def save_cache(); end

  def save_class(klass); end

  def save_method(klass, method); end

  def save_page(page); end

  def source(); end

  def title(); end

  def title=(title); end

  def type(); end

  def type=(type); end

  def unique_classes(); end

  def unique_classes_and_modules(); end

  def unique_modules(); end
end

class RDoc::Store::Error
end

class RDoc::Store::Error
end

class RDoc::Store::MissingFileError
  def file(); end

  def initialize(store, file, name); end

  def name(); end

  def store(); end
end

class RDoc::Store::MissingFileError
end

class RDoc::Store
end

module RDoc::Text
  def expand_tabs(text); end

  def flush_left(text); end

  def markup(text); end

  def normalize_comment(text); end

  def parse(text, format=T.unsafe(nil)); end

  def snippet(text, limit=T.unsafe(nil)); end

  def strip_hashes(text); end

  def strip_newlines(text); end

  def strip_stars(text); end

  def to_html(text); end

  def wrap(txt, line_len=T.unsafe(nil)); end
  MARKUP_FORMAT = ::T.let(nil, ::T.untyped)
  TO_HTML_CHARACTERS = ::T.let(nil, ::T.untyped)
end

module RDoc::Text
  def self.encode_fallback(character, encoding, fallback); end
end

module RDoc::TokenStream
  def add_token(*tokens); end

  def add_tokens(*tokens); end

  def collect_tokens(); end

  def pop_token(); end

  def start_collecting_tokens(); end

  def token_stream(); end

  def tokens_to_s(); end
end

module RDoc::TokenStream
  def self.to_html(token_stream); end
end

class RDoc::TomDoc
  def tokenize(text); end
end

class RDoc::TomDoc
  def self.add_post_processor(); end

  def self.parse(text); end

  def self.signature(comment); end
end

class RDoc::TopLevel
  def ==(other); end

  def absolute_name(); end

  def absolute_name=(absolute_name); end

  def add_to_classes_or_modules(mod); end

  def base_name(); end

  def classes_or_modules(); end

  def cvs_url(); end

  def diagram(); end

  def diagram=(diagram); end

  def eql?(other); end

  def file_stat(); end

  def file_stat=(file_stat); end

  def find_class_or_module(name); end

  def initialize(absolute_name, relative_name=T.unsafe(nil)); end

  def last_modified(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def object_class(); end

  def page_name(); end

  def parser(); end

  def parser=(parser); end

  def path(); end

  def relative_name(); end

  def relative_name=(relative_name); end

  def search_record(); end

  def text?(); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::TopLevel
end

module RDoc
  def self.load_yaml(); end
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::BacktraceCleaner
  DEFAULT_EXCLUSION_PATTERNS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  DEFAULT_ORDERING = ::T.let(nil, ::T.untyped)
  RANDOM_ORDERING = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
  MERGED_OPTIONS = ::T.let(nil, ::T.untyped)
  NON_FORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockFrameworkAdapter
  include ::RSpec::Matchers
end

class RSpec::Core::ExampleGroup::Nested_1
  include ::RSpec::Core::ExampleGroup::Nested_1::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_1::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_1::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_1::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_1
  extend ::RSpec::Matchers::DSL
end

class RSpec::Core::ExampleGroup::Nested_2
  include ::RSpec::Core::ExampleGroup::Nested_2::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_2::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_2::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_2::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_2::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_2::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_2::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_2
  extend ::RSpec::Matchers::DSL
end

class RSpec::Core::ExampleGroup::Nested_3
  include ::RSpec::Core::ExampleGroup::Nested_3::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_3::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_3::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_3::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_3::Nested_1
  include ::RSpec::Core::ExampleGroup::Nested_3::Nested_1::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_3::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::Nested_1::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_3::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::Nested_1::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_3::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::Nested_1::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1
  include ::RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_3::Nested_1::Nested_1
end

class RSpec::Core::ExampleGroup::Nested_3::Nested_1
end

class RSpec::Core::ExampleGroup::Nested_3
  extend ::RSpec::Matchers::DSL
end

class RSpec::Core::ExampleGroup::Nested_4
  include ::RSpec::Core::ExampleGroup::Nested_4::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_4::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_4::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_4::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_4::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_4::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_4::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_4
  extend ::RSpec::Matchers::DSL
end

class RSpec::Core::ExampleGroup::Nested_5
  include ::RSpec::Core::ExampleGroup::Nested_5::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_5::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_5::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_5::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_5::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_5::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_5::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_5
  extend ::RSpec::Matchers::DSL
end

class RSpec::Core::ExampleGroup::Nested_6
  include ::RSpec::Core::ExampleGroup::Nested_6::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_6::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_6::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_6::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_6::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_6::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_6::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_6
  extend ::RSpec::Matchers::DSL
end

class RSpec::Core::ExampleGroup::Nested_7
  include ::RSpec::Core::ExampleGroup::Nested_7::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_7::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_7::LetDefinitions
  include ::RSpec::Core::ExampleGroup::Nested_7::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_7::LetDefinitions
end

module RSpec::Core::ExampleGroup::Nested_7::NamedSubjectPreventSuper
end

module RSpec::Core::ExampleGroup::Nested_7::NamedSubjectPreventSuper
end

class RSpec::Core::ExampleGroup::Nested_7
  extend ::RSpec::Matchers::DSL
end

class RSpec::Core::FilterManager
  DEFAULT_EXCLUSIONS = ::T.let(nil, ::T.untyped)
  STANDALONE_FILTERS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::FilterManager::Describable
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Hooks
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

RSpec::Core::PendingExampleFixedError = RSpec::Core::Pending::PendingExampleFixedError

class RSpec::Core::Reporter
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Runner
  AT_EXIT_HOOK_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def around_each_hooks_for(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def its(*args, &block); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def run_hook(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Deprecation
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args, &block); end

  def match(_, actual); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  def initialize(operand, operator); end

  def negative_expectation_expression(); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalse
  def match(_, actual); end
end

class RSpec::Matchers::BuiltIn::BeFalse
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
  def match(_, actual); end
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def ===(actual); end

  def initialize(*args, &block); end
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTrue
  def match(_, actual); end
end

class RSpec::Matchers::BuiltIn::BeTrue
end

class RSpec::Matchers::BuiltIn::BeWithin
  def ==(actual); end

  def description(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(delta); end

  def matches?(actual); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

class RSpec::Matchers::BuiltIn::Change
  def ==(event_proc); end

  def actual_delta(); end

  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def description(); end

  def evaluate_value_proc(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def from(before); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def raise_block_syntax_error(); end

  def to(to); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::EndWith
  def element_matches?(expected, actual); end

  def subset_matches?(expected, actual); end
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  def ==(actual); end

  def description(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(expected, *args); end

  def matches?(actual); end
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::Have
  def ==(collection_or_owner); end

  def description(); end

  def determine_collection(collection_or_owner); end

  def determine_query_method(collection); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(expected, relativity=T.unsafe(nil)); end

  def matches?(collection_or_owner); end

  def not_a_collection(); end

  def relativities(); end

  def respond_to?(m); end
  QUERY_METHODS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Have
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def match(expected, actual); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::RaiseError
  def ==(given_proc, negative_expectation=T.unsafe(nil)); end

  def description(); end

  def does_not_match?(given_proc); end

  def eval_block(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(expected_error_or_message=T.unsafe(nil), expected_message=T.unsafe(nil), &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil)); end

  def verify_message(); end
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::RespondTo
  def ==(actual); end

  def argument(); end

  def arguments(); end

  def description(); end

  def does_not_match?(actual); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(*names); end

  def matches?(actual); end

  def with(n); end
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def ==(actual, &block); end

  def description(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(&block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::StartAndEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartAndEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
  def element_matches?(expected, actual); end

  def subset_matches?(expected, actual); end
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  def ==(given_proc); end

  def description(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  def at_least(number); end

  def at_most(number); end

  def exactly(number); end

  def initialize(); end

  def matches?(block); end

  def once(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def ==(block); end

  def description(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def ==(block); end

  def description(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

class RSpec::Matchers::DSL::Matcher
  PERSISTENT_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  EXPRESSION = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  EXPRESSION = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  EXPRESSION = ::T.let(nil, ::T.untyped)
end

RSpec::Mocks::ConstantStubber = RSpec::Mocks::ConstantMutator

class RSpec::Mocks::ExpectationTarget
  EXPRESSION = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::MethodDouble
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end
  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.urandom(_); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class Regexp
  def match?(*_); end
end

class Regexp
  def self.union(*_); end
end

class Ripper::Filter
  def column(); end

  def filename(); end

  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(init=T.unsafe(nil)); end

  def state(); end
end

class Ripper::Filter
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  def self.stat(*_); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def +@(); end

  def -@(); end

  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode(*_); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class Timecop
  VERSION = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def event(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::HTTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def request_uri(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.get_encoding(label); end
end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end
